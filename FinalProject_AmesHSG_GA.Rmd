---
title: "FinalProject_AmesHSG"
author: "Jaih, Katie, Andy, Anum"
date: "3/12/2021"
output:
  html_document:
    toc: yes
    toc_depth: 3
    code_folding: show
    theme: cerulean
    highlight: textmate
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r package_load}
library(ggplot2) # graphics library
library(knitr)   # contains kable() function
library(tree)    # For the tree-fitting 'tree' function
library(rpart)   # For nicer tree fitting
library(partykit)  # For nicer tree plotting
library(randomForest) # For random forests and bagging
library(ggcorrplot)
library(ModelMetrics) #Functions for MAE, MSE, RMSE etc.

options(scipen = 4)  # Suppresses scientific notation


library(tidyverse)
library(GGally)
library(gridExtra) # for grid.arrange
library(ggridges)
```


#Introduction
<font color="#800000">
We are going to examine the Ames Housing data-set to pick out some key characteristics, trends and summaries for our model evaluations with the eventual goal of developing a sales price prediction model that can be used to  improve  price listings. In doing so, we will subset our data to include houses sold in 2010 only, split it into test and training data-sets and evaluate key characteristics as a predictor of Sales Price to create an accurate model with the lowest error. Our final step will be to use our best model to create a function which will help advise any clients looking to evaluate the prices of clients home improvement or renovation projects. 

The following section will aim to clean-up the data for our use and identify general trends in sales prices across time, neighborhood, and other key home characteristics so that we can readily use the salient features for our prediction model. 
</font>

# Section 1: Exploratory Data Analysis  

```{r}
#read in data
housing.raw <- read.csv("AmesHousing.csv", fileEncoding="UTF-8-BOM")
```

```{r}
#summary(housing.raw)
glimpse(housing.raw)
#Checking the class of each variable
categories.housing <- data.frame(variabletype=sapply(housing.raw,class))
categories.housing
```
```{r}
numeric_variables <- table(categories.housing[categories.housing['variabletype'] == 'integer'])
numeric_variables
categorical_variables <- table(categories.housing[categories.housing['variabletype'] == 'character'])
categorical_variables
```


```{r}
#Checking the number of NA values in the data-set to evaluate clean-up
sum(is.na(housing.raw))
```

<font color="#800000">
On first glance, we see a few salient features within the dataset with 39 integer variables which include: 
-MS.Subclass
-Lot.Frontage
- Lot.Area
- Overall.Qual
- Overall.Cond
- Year.Built
- Year.Remod.Add
- Full.Bath				
- Half.Bath		
- Bedroom.AbvGr			
- Kitchen.AbvGr
- TotRms.AbvGrd
- Mo.Sold			
- Yr.Sold	
- SalePrice	

We see 43 character variables which include: 
- MS.Zoning
- Utilities
- Neighborhood
- Heating
- Central.Air
- Kitchen.Qual

The dataset also has `r sum(is.na(housing.raw))` NA values. However, in most cases this corresponds to the characteristic not being present in the house; therefore, we will proceed to change these 'NA' values to "None" where it makes sense to not lose any relevant data. e.g --> Pool.QC.

After cleaning the data, we are will split it into train and test; whereby, the testing data is based on houses purchased in 2010 and the training data will be those house purchased before 2010. 
</font>

```{r}
length.data.raw <- nrow(housing.raw)

#Replace empty strings with NA so that ensuing functions can mutate them
#Code example taken from: (https://stackoverflow.com/questions/51449243/how-to-replace-empty-string-with-na-in-r-dataframe)
housing.raw[housing.raw==""] <- NA

#Replace NA values from data adapted from (https://stackoverflow.com/questions/8161836/how-do-i-replace-na-values-with-zeros-in-an-r-dataframe)
housing.clean <- housing.raw %>% 
  mutate_if(is.character, ~replace(., is.na(.), "None")) %>%
  mutate_if(is.numeric, ~replace(., is.na(.), 0))

#Identifying empty strings
housing.processed <- housing.clean %>%
  mutate(Bsmt.Cond = recode(Bsmt.Cond,"Po" = 1, "Fa" = 2, "TA" = 3, "Gd" = 4, "Ex" = 5, .default = 0)) %>%
  mutate(Bsmt.Exposure = factor(Bsmt.Exposure, levels = c("Gd","Av","Mn","No", "None"))) %>%
  mutate(Fireplace.Qu = recode(Fireplace.Qu,"Po" = 1, "Fa" = 2, "TA" = 3, "Gd" = 4, "Ex" = 5, .default = 0))%>%
  mutate(Garage.Qual = recode(Garage.Qual,"Po" = 1, "Fa" = 2, "TA" = 3, "Gd" = 4, "Ex" = 5, .default = 0))%>%
  mutate(Bsmt.Qual = recode(Bsmt.Qual,"Po" = 1, "Fa" = 2, "TA" = 3, "Gd" = 4, "Ex" = 5, .default = 0))%>%
  mutate(Heating.QC = factor(Heating.QC, levels = c("Ex", "Gd", "TA", "Fa", "Po"))) %>%
  mutate(Kitchen.Qual = recode(Kitchen.Qual,"Po" = 1, "Fa" = 2, "TA" = 3, "Gd" = 4, "Ex" = 5, .default = 0))%>%
  mutate(Exter.Qual = recode(Exter.Qual,"Po" = 1, "Fa" = 2, "TA" = 3, "Gd" = 4, "Ex" = 5, .default = 0))%>%
  mutate(Exter.Cond = recode(Exter.Cond,"Po" = 1, "Fa" = 2, "TA" = 3, "Gd" = 4, "Ex" = 5, .default = 0))%>%
  mutate(Functional = factor(Functional, levels = c("Typ", "Min1", "Min2", "Mod", "Maj1", "Maj2", "Sev", "Sal"))) %>%
  mutate(Garage.Finish = factor(Garage.Finish, levels = c("Fin", "RFn", "Unf", "None"))) %>%
  mutate(Pool.QC = recode(Pool.QC,"Po" = 1, "Fa" = 2, "TA" = 3, "Gd" = 4, "Ex" = 5, .default = 0))%>%
  mutate(Heating.QC = recode(Heating.QC,"Po" = 1, "Fa" = 2, "TA" = 3, "Gd" = 4, "Ex" = 5, .default = 0))%>%
  mutate(Garage.Cond = recode(Garage.Cond,"Po" = 1, "Fa" = 2, "TA" = 3, "Gd" = 4, "Ex" = 5, .default = 0)) %>%
  mutate(Lot.Shape = factor(Lot.Shape, levels = c("Reg","IR1","IR2","IR3"))) %>%
  mutate(Land.Slope = factor(Land.Slope, levels = c("Gtl","Mod","Sev"))) %>%
  mutate(MS.Zoning = factor(MS.Zoning, levels = c("RL","RH","FV","RM","C (all)","I (all)","A (agr)"), ordered = FALSE)) %>%
  mutate(MS.SubClass = recode_factor(MS.SubClass, 
                                     '20' = "1-STORY 1946N",
                                     '30' = "1-STORY 1945O",
                                     '40' = "1-STORY UF.ATTIC.A",
                                     '45' = "1.5 STORY UF.A",
                                     '50' = "1.5-STORY F.ATTIC.A",
                                     '60' = "2-STORY 1946N",
                                     '70' = "2-STORY 1945O",
                                     '75' = "2.5-STORY A",
                                     '80' = "MULTILVL",
                                     '85' = "SPLIT FOYER",
                                     '90' = "DUPLEX.A",
                                     '120' = "1-STORY-PUD 1946N",
                                     '150' = "1.5-STORY-PUD.A",
                                     '160' = "2-STORY-PUD 1946N",
                                     '180' = "PUD-MULTILVL",
                                     '190' = "2 FAM CONV.A"))

housing.processed <- na.fail(subset(housing.processed, select = -c(Order,PID)))

test <- which(housing.processed$Yr.Sold==2010)
train <- which(housing.processed$Yr.Sold<2010)

housing.train <- housing.processed[train,]
housing.test <- housing.processed[test,]

#terminology used is N for New, O for Old, A for All
        #20	1-STORY 1946 & NEWER ALL STYLES
        #30	1-STORY 1945 & OLDER
        #40	1-STORY W/FINISHED ATTIC ALL AGES
        #45	1-1/2 STORY - UNFINISHED ALL AGES
        #50	1-1/2 STORY FINISHED ALL AGES
        #60	2-STORY 1946 & NEWER
        #70	2-STORY 1945 & OLDER
        #75	2-1/2 STORY ALL AGES
        #80	SPLIT OR MULTI-LEVEL
        #85	SPLIT FOYER
        #90	DUPLEX - ALL STYLES AND AGES
       #120	1-STORY PUD (Planned Unit Development) - 1946 & NEWER
       #150	1-1/2 STORY PUD - ALL AGES
       #160	2-STORY PUD - 1946 & NEWER
       #180	PUD - MULTILEVEL - INCL SPLIT LEV/FOYER
       #190	2 FAMILY CONVERSION - ALL STYLES AND AGES
```



# Initial Data Plots and Summaries
<font color="#800000">
Now that we've done some cleaning; let's go on to explore our main dependent variable: SalePrice. 
</font>

```{r, warning = FALSE}
summary(housing.train$SalePrice)

# Histogram
qplot(housing.train$SalePrice, col = I("black"), fill = I("forest green")) + 
  xlab("Sales Price") + 
  ggtitle("Distribution of Sale Price in Data") 
```

<font color="#800000">
The data seems to have a slight right skewed distribution with a mean pricing of 181,876.  
</font>

<font color="#800000">
For a better sense of the numeric variables that constitute area and key characteristics, we look at the histogram for a few. Given the importance of property size metrics, we quickly zoomed in on “Gr.Liv.Area”, “Lot.Area” and “Garage.Area” as potential explanatory variables.
</font>

```{r}
par(mfrow = c(3, 3))
hist(housing.train$Lot.Frontage, breaks = 20, main = "Feet of Street Connected to Property", xlab = "Lot Frontage", border="red", col="steelblue")
hist(housing.train$Lot.Area, breaks = 20, main = "Lot Area in Square Feet", xlab = "Lot Area", border="red", col="steelblue")
hist(housing.train$Gr.Liv.Area, breaks = 20, main = "Above Ground Living Area",  xlab = "Above Ground Living Area", border="red", col="steelblue")
hist(housing.train$Pool.Area, breaks = 20, main = "Pool Area",  xlab = "Pool Area", border="red", col="steelblue")
hist(housing.train$Total.Bsmt.SF, breaks = 20, xlab = "Basement Square Feet", main = "Total Basement Square Feet", border="red", col="steelblue")
hist(housing.train$Year.Built, breaks = 20, main = "Year Built", xlab = "Year Built", border="red", col="steelblue")
hist(housing.train$Full.Bath, breaks = 20, main = "Full Bath", xlab = "Full Bath", border="red", col="steelblue")
hist(housing.train$Bedroom.AbvGr, breaks = 20, main = "Bedroom Above Ground", xlab = "Bedroom Above Ground", border="red", col="steelblue")
hist(housing.train$Garage.Area, breaks = 20, main = "Garage Area", xlab = "Garage Area",  border="red", col="steelblue")
```

<font color="#800000">
Intuitively, neighborhoods are a relevant predictor for sale price: more expensive neighborhoods would have higher prices, so we proceed to make summary tables and boxplots to visualize this relationship. 
</font>

```{r, warning = FALSE}
neighborhood.eval <- housing.train %>%
  group_by(Neighborhood) %>%
  dplyr::summarize(Averageprice = mean(SalePrice), 
            Medianprice = median(SalePrice), .groups = "keep")

kable(neighborhood.eval)
```

```{r}
housing.train %>%
        ggplot(aes(x = SalePrice / 1000, y = Neighborhood, fill = Neighborhood)) +
        geom_density_ridges(scale = 4) +
        theme_ridges() +
        theme(legend.position = "none") +
        xlab("Home Price in '000's") +
        theme(axis.title.y = element_blank())
```


<font color="#800000">
'StoneBr', 'NridgeHt' and 'NoRidge' seem to be the more pricier neighborhoods, and the density plots show that the prices across these neighborhoods tend to vary more. We can also see that the least expensive homes are likely in ‘MeadowV. Our intuition was spot on: the sales price varies with different neighborhoods, so we should definitely include this in our model as a predictor.

https://rpubs.com/sknapp/667278 

Other characteristics that stands out are the quality characteristics. We expect there to be a strong linear relationship between quality and prices. The poorer the quality, the lower the price which we expect to be strong predictors in our model.
</font>

```{r}
qual.plot <- ggplot(housing.train, aes(Overall.Qual,SalePrice)) + geom_jitter(alpha = 0.5, color = "blue")  + labs( x = "Overall Quality of House", y = "Sales Price")

qual.plot2 <- ggplot(housing.train, aes(Kitchen.Qual,SalePrice)) + geom_jitter(alpha = 0.5, color = "blue") + labs( x = "Kitchen Quality", y = "Sales Price")


qual.plot3 <- ggplot(housing.train, aes(Bsmt.Qual,SalePrice)) + geom_jitter(alpha = 0.5, color = "blue") + labs( x = "Basement Quality", y = "Sales Price")

qual.plot4 <- ggplot(housing.train, aes(Exter.Qual,SalePrice)) + geom_jitter(alpha = 0.5, color = "blue") + labs( x = "Exterior Quality", y = "Sales Price")

qual.plot5 <- ggplot(housing.train, aes(Garage.Qual,SalePrice)) + geom_jitter(alpha = 0.5, color = "blue") + labs( x = "Garage Quality", y = "Sales Price")

library(cowplot)
plot_grid(qual.plot, qual.plot2, qual.plot3, qual.plot4, qual.plot5, labels = "AUTO")
```

<font color="#800000">
The type of house one lives in is a strong determinant of price. There are many outliers for 1- Story, 2-Story 1946 Newer Houses which is understandable given their might be other omitted variables we are not considering. 
</font>


```{r}
ggplot(data = housing.train, aes(x = SalePrice, y = MS.SubClass)) +
  geom_boxplot() + labs(x = "Sale Price", y = "Type of Dwelling")
```
<font color="#800000">
The dataset covers 2006-2010 which falls within the years of the Great Recession. The Great Recession was a period of marked general decline observed in national economies globally that began in December 2007 and ended in June 2009.  Home prices fell approximately 30 percent, on average, from their mid-2006 peak to mid-2009. Source URL: https://www.federalreservehistory.org/essays/great-recession-of-200709.

Given this fact, it is actually surprising that the dataset does not reflect a decrease in prices; but a stagnant rate across the five years in the graph below.
</font>

```{r}
housing.train %>% ggplot(aes(x = Yr.Sold, y= SalePrice/1000)) + geom_jitter() + stat_smooth(method = "lm") + ggtitle("Housing Prices Between 2006-2010") + xlab("Year Sold") + ylab("Price in $1000")
```

<font color="#800000">
We also think it's meaningful to explore the relationship between price and year built. Generally, newer houses tend to be more expensive but there could elite neighborhoods with older houses that have a higher price. Let's see if this could be valuable for our model.
</font>


```{r}
year.plot <- ggplot(housing.train, aes(Year.Built,SalePrice)) + geom_jitter(alpha = 0.5, color = "blue")
year.plot
```

```{r}
housing.train %>%
        ggplot(aes(Year.Built)) +
        geom_histogram(bins = 30, fill = "yellow", color = "black") +
        geom_vline(aes(xintercept = mean(Year.Built), 
                   color = "mean"), linetype = "dashed", size = 1) +
        geom_vline(aes(xintercept = median(Year.Built), 
                   color = "median"), linetype = "dashed", size = 1) +
        scale_color_manual(name = "Statistics", values = c(mean = "red", median = "blue")) +
        ggtitle("Histogram of Year Homes were Built in Ames") +
        xlab("Year Built") + ylab("Number of Homes")
```
* reference source: https://rpubs.com/sknapp/667278

<font color="#800000">
Just as we expected, we see that newer houses tend to be more expensive in the data-set. However, there are a few outliers which exhibit the opposite: very old houses appear to increase in price. Perhaps these could be considered as "old century homes" built in years prior to 1920 which would no longer correspond to a price decrease with age. Furthermore, our data-set seems to have a higher frequency of homes in the early 2000s which is a good indicator for our potential prediction model.
</font>



<font color="#800000">
For the purpose of making our final prediction model leaner, we will explore variables that might exhibit high collinearity. Intuitively, it looks like there are some extra variables which may not be necessary. For example, our expectation is that Lot.Frontage and Lot.Area will be highly correlated. Similarly, Bedroom.AbvGr and TotRms.AbvGrd might follow a similar trend. We look further into the correlations between the numeric variables.
</font>


```{r}
# create a subset of variable names
myvars <- c("Lot.Frontage","Lot.Area", "Year.Built", "Year.Remod.Add", "Mas.Vnr.Area","Total.Bsmt.SF", "Bsmt.Unf.SF", "BsmtFin.SF.2","BsmtFin.SF.1", "X1st.Flr.SF","X2nd.Flr.SF", "Low.Qual.Fin.SF","Gr.Liv.Area", "Bsmt.Full.Bath","Bsmt.Half.Bath", "Full.Bath", "Half.Bath", "Bedroom.AbvGr","Kitchen.AbvGr", "Fireplaces", "TotRms.AbvGrd","Garage.Yr.Blt","Garage.Cars", "Garage.Area", "Wood.Deck.SF",	"Open.Porch.SF","Enclosed.Porch", "X3Ssn.Porch",	"Screen.Porch", "Pool.Area", "SalePrice", "Mo.Sold","Yr.Sold")

sub.house <- housing.train[myvars]

#Create a data frame for variables that are correlated 
corr.sub.house <- round(cor(sub.house),2)
corr.table <- as.data.frame(as.table(corr.sub.house))
names(corr.table)[1] <- "Variable 1"
names(corr.table)[2] <- "Variable 2"

#Find the variables which are strongly correlated as per rule of 0.6
corr.subset <- subset(corr.table,  Freq > 0.6 | Freq < -0.6) 
high.corr <- data.frame(corr.subset)
high.corr <- high.corr[order(high.corr$Freq),]
high.corr <- high.corr %>%
  filter(Freq < 1)
name1 <- as.character(high.corr$Variable.1)
name2 <- as.character(high.corr$Variable.2)
hi.cor.vars <- unique(append(name1, name2))
```


```{r, fig.width = 15}
#highly correlated variables
sub.house.high <- housing.train[hi.cor.vars]
corr.sub.house.high <- round(cor(sub.house.high),2)


#Use ggcorrplot to graph correlation. 
ggcorrplot(corr.sub.house.high, hc.order = TRUE, outline.color = 'white', lab = TRUE, title = "Highly Correlated Variables in Housing Dataset", legend.title = "Correlation")
```
```{r}
high.corr
```

<font color="#800000">
As expected, we do see correlation between variables such as:TotRms.AbvGrd and Bedroom.AbvGr, X1st.Flr.SF	and Total.Bsmt.SF, SalePrice and	Gr.Liv.Area.  Based on intuition, we split the variables into sub-categories to further explore collinearity. This will help us zoom into some characteristics into narrowing down to our first simple model.
</font>

```{r}
#Features
hsg.features <- c("Utilities", "Bldg.Type","House.Style","Roof.Style",
                  "Roof.Matl","Exterior.1st","Exterior.2nd","Foundation",
                  "Bsmt.Unf.SF","Total.Bsmt.SF","Heating","Heating.QC",
                  "Central.Air","Electrical","Fireplaces","Garage.Type",
                  "Garage.Finish","Garage.Area","Paved.Drive","Misc.Feature",
                  "Misc.Val")

#Quality
hsg.quality <- c("Overall.Qual","Overall.Cond","Exter.Qual","Exter.Cond",
                 "Bsmt.Cond","Bsmt.Qual","Bsmt.Exposure","BsmtFin.Type.1",
                 "BsmtFin.Type.2","Heating.QC","Fireplace.Qu","Garage.Finish",
                 "Garage.Qual","Garage.Cond","Fence","Misc.Val","Pool.QC",
                 "Sale.Condition")

#Sales Criteria
sales.crit <- c("MS.SubClass", "MS.Zoning", "Year.Built", "Year.Remod.Add",
                "Mo.Sold", "Yr.Sold", "Sale.Type")

#Geo-Spatial Characteristics
geo.char <- c("Lot.Area","Lot.Frontage","Mas.Vnr.Area","X1st.Flr.SF","X2nd.Flr.SF","Garage.Area","Wood.Deck.SF",
              "Open.Porch.SF","Pool.Area", "Low.Qual.Fin.SF","Gr.Liv.Area")


#Basement/Bath Redundancies
bb.crit <- c("BsmtFin.SF.1", "BsmtFin.SF.2", "Bsmt.Unf.SF", "Total.Bsmt.SF", 
             "Bsmt.Full.Bath", "Bsmt.Half.Bath", "Full.Bath","Half.Bath")

#Above Ground
ag.crit <- c("Bedroom.AbvGr", "Kitchen.AbvGr", "TotRms.AbvGrd", "Gr.Liv.Area")

#Deck/Porch
dp.crit <- c("Wood.Deck.SF", "Open.Porch.SF", "Enclosed.Porch","X3Ssn.Porch","Screen.Porch")


sub.house.geo <- housing.train[geo.char]
corr.sub.house.geo <- round(cor(sub.house.geo),2)

sub.house.bb.crit <- housing.train[bb.crit]
corr.sub.house.bb <- round(cor(sub.house.bb.crit),2)

sub.house.ag.crit <- housing.train[ag.crit]
corr.sub.house.ag <- round(cor(sub.house.ag.crit),2)

sub.house.dp.crit <- housing.train[dp.crit]
corr.sub.house.dp <- round(cor(sub.house.dp.crit),2)

```


```{r, fig.width = 15}
#Use ggcorrplot to graph correlation. 
ggcorrplot(corr.sub.house.geo, hc.order = TRUE, outline.color = 'white', lab = TRUE, title = "Correlation between Geo-Spatial Characteristics in Housing Dataset", legend.title = "Correlation")
```

```{r, fig.width = 15}
#Use ggcorrplot to graph correlation. 
ggcorrplot(corr.sub.house.bb, hc.order = TRUE, outline.color = 'white', lab = TRUE, title = "Correlation between Basement-Bath Characteristics in Housing Dataset", legend.title = "Correlation")
```
```{r, fig.width = 15}
#Use ggcorrplot to graph correlation. 
ggcorrplot(corr.sub.house.ag, hc.order = TRUE, outline.color = 'white', lab = TRUE, title = "Correlation between Basement-Bath Characteristics in Housing Dataset", legend.title = "Correlation")
```
```{r, fig.width = 15}
#Use ggcorrplot to graph correlation. 
ggcorrplot(corr.sub.house.dp, hc.order = TRUE, outline.color = 'white', lab = TRUE, title = "Correlation between Basement-Bath Characteristics in Housing Dataset", legend.title = "Correlation")
```


```{r}
#Helper Functions
calcRelErr <- function(preds, actual) {
  (preds - actual)/actual
}
   

getbaselineRow<-function(subclass, neighborhood, value){
   sub.indexes<-which(housing.processed$MS.SubClass == subclass)
   nb.indexes<- which(housing.processed$Neighborhood == neighborhood)
   val.indexes <- which(housing.processed$SalePrice >= value - 10000 & housing.processed$SalePrice <= value + 10000)
   
   commonList <- intersect(sub.indexes,intersect(nb.indexes,val.indexes))
   
   if (length(commonList) > 0){
     train.index <- sample(commonList, 1)
   } else {
     train.index <- sample(nrow(housing.processed), 1)
   }
   
  housing.train[train.index,]
}

```

# Section 2: Methodology
## Inital Linear Regressions 

<font color="#800000">
As an initial simple model we will consider a few variables to be important determinants of the price of a property:

- Overall.Qual: The quality rating (from 1 to 10).
- Kitchen.Qual
- Neighborhood: Neighborhoods vary across location as per our EDA.
- MS.SubClass
- MS.Zoning.
- Lot.Area
- Year.Built 
- Total.Bsmt.SF
- Gr.Liv.Area
- Open.Porch.SF
- Pool.Area
</font>

```{r}
lm.fit.1 <- lm(SalePrice ~
                 Overall.Qual +
                 Kitchen.Qual +
                 Neighborhood +
                 MS.SubClass +
                 MS.Zoning +
                 Lot.Area +
                 Year.Built +
                 Total.Bsmt.SF + 
                 Gr.Liv.Area +
                 Open.Porch.SF +
                 Pool.Area,
               data = housing.train)
summary(lm.fit.1)


lm.preds = predict(lm.fit.1, newdata=housing.test)
lm.resid = housing.test$SalePrice - lm.preds

#Residual Plot for Linear Model 1
ggplot(data=data.frame(lm.preds, lm.resid), aes(lm.preds,lm.resid)) +
  geom_point(size=1,colour="lightblue") +
  geom_hline(yintercept = mean(lm.resid), color="red")+
  theme_bw() 


lm.MAE <- mae(actual=housing.test$SalePrice, predicted=lm.preds, lm.fit.1)
lm.RMSE <- rmse(actual=housing.test$SalePrice, predicted=lm.preds, lm.fit.1)

paste("MAE: ", lm.MAE )
paste("RMSE: ", lm.RMSE)
paste("Mean RelErr: ", mean(calcRelErr(preds=lm.preds, housing.test$SalePrice)))


```
`
<font color="#800000">
Running our multiple regression model shows that a one unit change in overall quality is associated with a 14,958 dollars increase in Sales Price and is statistically significant.  Similarly, a one unit change in overall quality is associated with a $14,958 increase in Sales Price and it is also statistically significant. 

Before creating different models we will zoom into one metric that we will use for evaluation purposes from Mean Absolute Error, Root-Mean Squared Error and Mean Relative Error:

The MAE measures the average magnitude of errors in a set of prediction. It’s the average over the test sample of the absolute differences between prediction and actual observation where all individual differences have equal weight. The RMSE gives a relatively high weight to large errors. This means the RMSE should be more useful when large errors are particularly undesirable. In the case of our housing model, we want our prediction to be accurate to an average home; which is why MAE makes more sense. 

We will stick to MAE when comparing with other models of evaluation. 

https://medium.com/human-in-a-machine-world/mae-and-rmse-which-metric-is-better-e60ac3bde13d
</font>


## Lasso Model

<font color="#800000">
We think we can do better than the MAE from our linear model. The second model we want to test out is the Lasso regression because our data-set is indicative of high levels of multi-collinearity and we want to automate certain parts of model selection i.e variable selection or parameter elimination.
</font>

```{r}
library(glmnet)
#Lasso 
x <- model.matrix(SalePrice~.,housing.processed)[,-1]
y <- housing.processed$SalePrice

#Create Lasso Models for CV
grid=10^seq(10,-2, length =100)
lasso.mod=glmnet(x[train,],y[train],alpha=1,lambda=grid)
plot(lasso.mod)

#Run CV
set.seed(1)
cv.out=cv.glmnet(x[train,],y[train],alpha=1)
plot(cv.out)

#Find BestLam from CV
bestlam=cv.out$lambda.min


lasso.coef = predict(lasso.mod,type="coefficients",s=bestlam)[1:40,]
kable(lasso.coef[lasso.coef!=0])
length(lasso.coef[lasso.coef!=0])

lasso.pred=predict(lasso.mod,s=bestlam,newx=x[test,])
lasso.resid = housing.test$SalePrice - lasso.pred

#Residual Plot for Lasso Model 1
ggplot(data=data.frame(lasso.pred, lasso.resid), aes(lasso.pred,lasso.resid)) +
  geom_point(size=1,colour="lightblue") +
  geom_hline(yintercept = mean(lasso.resid), color="red")+
  theme_bw() 



paste("MAE: ", mae(predicted=lasso.pred, actual=y[test], lasso.mod))
paste("RMSE: ", rmse(predicted=lasso.pred, actual=y[test], lasso.mod))
paste("Mean RelErr: ", mean(calcRelErr(preds=lasso.pred, y[test])))
```
<font color="#800000">
There is an approximately ~ 2,000 dollar reduction in MAE which is great for our prediction model but not that useful for our renovation function, we want a model that includes important indicative variables which are usually an "ask" during restructing of houses such as: kitchen quality and bathroom characteristics and this seems to eliminate them.  
</font>



## GAM Model

```{r}
library(gam)
library(plyr)
library(dplyr)
```


```{r}
#Poly, cubic, natural, and smoothing
polyTestErr <- function(dat, train, d) {
  poly.fit <- lm(y ~ poly(x, degree = d), data = dat, subset = train)
  preds <- predict(poly.fit, dat)[-train]
  mean((dat$y[-train] - preds)^2)
}

cubicSplineTestErr <- function(dat, train, df) {
  if(df >= 3) {
    spline.fit <- lm(y ~ bs(x, df = df), data = dat, subset = train)
    preds <- predict(spline.fit, dat)[-train]
    mean((dat$y[-train] - preds)^2)
  } else {
    NA
  }
}

naturalSplineTestErr <- function(dat, train, df) {
  if(df >= 1) {
    spline.fit <- lm(y ~ ns(x, df = df), data = dat, subset = train)
    preds <- predict(spline.fit, dat)[-train]
    mean((dat$y[-train] - preds)^2)
  } else {
    NA
  }
}

smoothSplineTestErr <- function(dat, train, df) {
  if(df > 1) {
    spline.fit <- with(dat, smooth.spline(x[train], y[train], df = df))
    preds <- predict(spline.fit, dat$x)$y[-train]
    mean((dat$y[-train] - preds)^2)
  } else {
    NA
  }
}

```


```{r}
smoothCV <- function(x, y, K = 10, df.min = 1, df.max = 10) {
  dat <- data.frame(x = x, y = y)
  n <- length(y) # number of observations
  
  num.methods <- 4
  method.names <- c("poly", "cubic.spline", "natural.spline", "smoothing.spline")
  err.out <- data.frame(df = rep(df.min:df.max, each = num.methods),
                        method = rep(method.names, df.max - df.min + 1))
  set.seed(1)
  # Get a random permutation of the indexes
  random.perm <- sample(n)
  # break points for the folds.  If n is not evenly divisible by K,
  # these may not be of exactly the same size.
  fold.breaks <- round(seq(1,n+1, length.out = K + 1))
  fold.start <- fold.breaks[1:K]
  fold.end <- fold.breaks[2:(K+1)] - 1
  fold.end[K] <- n # Fix the last endoint to equal n
  fold.size <- fold.end - fold.start + 1 # num obs in each fold
  
  cv.err <- NULL
  fold.err <- matrix(0, nrow = K, ncol = 4)
  colnames(fold.err) <- c("poly", "cubic.spline", "natural.spline", "smoothing.spline")
  # Outer loop: Loop over degrees of freedom
  # Inner loop: Iterate over the K folds
  for(df in df.min:df.max) {
    for(k in 1:K) {
      test.idx <- fold.start[k]:fold.end[k]
      train <- random.perm[-test.idx]
      
      # Calculate test error for the four models
      poly.err <- polyTestErr(dat, train = train, d = df)
      cubic.spline.err <- cubicSplineTestErr(dat, train = train, df = df)
      natural.spline.err <- naturalSplineTestErr(dat, train = train, df = df)
      smooth.spline.err <- smoothSplineTestErr(dat, train = train, df = df)
      
      # Store results for this fold
      fold.err[k,] <- c(poly.err, cubic.spline.err, natural.spline.err, smooth.spline.err)
#       print(fold.err[k,])
    }
    # Perform weighted averaging to calculate CV error estimate
    # MSE estimates from each fold are weighted by the size of the fold
    # If all folds are the same size, this is the same thing as the unweighted
    # average of all of the MSE's
    err.ave <- colSums(sweep(fold.err, MARGIN = 1, fold.size, FUN = "*") / n)
    cv.err <- c(cv.err, err.ave)
  }
  err.out$cv.error <- cv.err
  err.out
}
```

```{r}
# This plotting approach has a facet option which allows the user to show
# three separate plots instead of overlaying the curves
# If y.scale.factor is non-null, the range of the 
# y-axis for the plot is restricted to y.min to y.min*y.scale.factor
plot.smoothCV <- function(smoothcv.err, K, title.text = "", facet = FALSE,
                          y.scale.factor = NULL) {

  # Convert the method names
  dat <- transform(smoothcv.err, 
                   method = mapvalues(method,
                                      c("poly", "cubic.spline", "natural.spline", "smoothing.spline"),
                                      c("Polynomial", "Cubic Spline", "Natural Spline", "Smoothing Spline")
                                      )
                   )
  
  # Set axes labels
  x.text <- "Degrees of Freedom"
  y.text <- paste0(K, "-fold CV Error")
  
  # The ggplot "setting": data, axes, and color by method
  p <- ggplot(data = dat, aes(x = df, y = cv.error, colour = method)) 
  
  # Overlay with line plots, data points, axes labels, and graph title
  p <- p + geom_line() + geom_point() + xlab(x.text) + ylab(y.text) +
          ggtitle(title.text)
  
  # Adjust the y axis range if y.scale.factor is specified
  if(!is.null(y.scale.factor)) {
    min.err <- min(dat$cv.error, na.rm = TRUE)
    p <- p + ylim(min.err, y.scale.factor * min.err)
  }
  
  # Show a separate plot per method if facet=TRUE
  if(!facet) {
    print(p)
  } else {
    print(p + facet_wrap("method"))
  }
}
```

### Finding models with lowest CV Error

<font color="#800000">
As per our earlier analyses, the following variables seem to be key components in evaluating a GAM model:

Variables to use: Gr.Liv.Area, Overall.Qual, X1st.Flr.SF, MS.SubClass, X2nd.Flr.SF, Total.Bsmt.SF, MS.Zoning, Full.Bath, Kitchen.Qual, Neighborhood, and Central.Air
</font>



```{r}
gr.area.cv <- smoothCV(x = housing.train$Gr.Liv.Area,
         y = housing.train$SalePrice,
         K = 10,
         df.min = 1,
         df.max = 10)

plot.smoothCV(gr.area.cv, K = 10, title.text = "CV Error: SalePrice ~ Gr.Liv.Area",
              y.scale.factor = 1.1)
```
<font color="#800000">
We will use a cubic spline of 4 with the variable Gr.Liv.Area. This has the lowest 10-fold CV error. 
</font>



```{r}
qual.cv <- smoothCV(x = housing.train$Overall.Qual,
         y = housing.train$SalePrice,
         K = 10,
         df.min = 1,
         df.max = 9)

plot.smoothCV(qual.cv, K = 10, title.text = "CV Error: SalePrice ~ Overall.Qual")
```

<font color="#800000">
Our CV error model suggests we use a natural spline with df = 3. Our earlier analysis showed a linear relationship between price and overall quality and it is a key predictor for our model. When finalizing we will run estimates with both to see which adds more value to our model with less error. 
</font>



```{r}
X1st.flr.cv <- smoothCV(x = housing.train$X1st.Flr.SF,
         y = housing.train$SalePrice,
         K = 10,
         df.min = 1,
         df.max = 10)

plot.smoothCV(X1st.flr.cv, K = 10, title.text = "CV Error: SalePrice ~ 1st.Flr.SF",
              y.scale.factor = 1.1)
```

<font color="#800000">
We will use a polynomial with degree 6 for 1st.Flr.SF. 
</font>


```{r}
X2nd.flr.cv <- smoothCV(x = housing.train$X2nd.Flr.SF,
         y = housing.train$SalePrice,
         K = 10,
         df.min = 1,
         df.max = 10)

plot.smoothCV(X2nd.flr.cv, K = 10, title.text = "CV Error: SalePrice ~ 2nd.Flr.SF",
              y.scale.factor = 1.1)
```

<font color="#800000">
We will use a polynomial with degree 3 for 2nd.Flr.SF
</font>



```{r}
basement.cv <- smoothCV(x = housing.train$Bsmt.Qual,
         y = housing.train$SalePrice,
         K = 10,
         df.min = 1,
         df.max = 5)

plot.smoothCV(basement.cv, K = 10, title.text = "CV Error: SalePrice ~ Bsmt.Qual",
              y.scale.factor = 1.1)
```


<font color="#800000">
We will use a smoothing spline with degree 5 for Bsmt.Qual
</font>


```{r}
bath.cv <- smoothCV(x = housing.train$Full.Bath,
         y = housing.train$SalePrice,
         K = 10,
         df.min = 1,
         df.max = 4)

plot.smoothCV(bath.cv, K = 10, title.text = "CV Error: SalePrice ~ Full.Bath",
              y.scale.factor = 1.1)
```

<font color="#800000">
We will use a polynomial with df = 3 
</font>


```{r}
kitchen.cv <- smoothCV(x = housing.train$Kitchen.Qual,
         y = housing.train$SalePrice,
         K = 10,
         df.min = 1,
         df.max = 3)

plot.smoothCV(kitchen.cv, K = 10, title.text = "CV Error: SalePrice ~ Kitchen.Qual")
```

<font color="#800000">
Our CV error model suggests we use a polynomial with df = 2. As with overall quality, kitchen quality is a salient predictor and our initial summaries corroborate the finding of a linear relationship between price and kitchen quality; we will go for a linear fit. 
</font>

```{r}

gam.fit <- gam(SalePrice ~ bs(Gr.Liv.Area, 4) + ns(Overall.Qual, 3) + s(X1st.Flr.SF, 7) + MS.SubClass +
                 bs(X2nd.Flr.SF, 6) + MS.Zoning + poly(Full.Bath, 3) + 
                 poly(Kitchen.Qual, 2) + Neighborhood + Central.Air, data = housing.train)

summary(gam.fit)

gam.deviance <- 1 - gam.fit$deviance/gam.fit$null.deviance
gam.deviance
```

```{r}
gam.preds <- predict(gam.fit, newdata = housing.test)
gam.MAE <- mae(actual=housing.test$SalePrice, predicted=gam.preds, gam.fit)
gam.RMSE <- rmse(actual=housing.test$SalePrice, predicted=gam.preds, gam.fit)

gam.resid = housing.test$SalePrice - gam.preds

#Residual Plot for Linear Model 1
ggplot(data=data.frame(gam.preds, gam.resid), aes(gam.preds,gam.resid)) +
  geom_point(size=1,colour="lightblue") +
  geom_hline(yintercept = mean(gam.resid), color="red")+
  theme_bw() 

paste("MAE: ",gam.MAE)
paste("RMSE: ",gam.RMSE)
paste("Mean RelErr: ", mean(calcRelErr(preds=gam.preds, actual=housing.test$SalePrice)))

```


<font color="#800000">
Our GAM model accounts for roughly 88.9% of the deviance explained. The percent deviance explained is the Generalized Additive Model analog of R-squared. It is exactly equal to the R-squared for regression models that can be fit with both the gam and lm functions. After cutting down to relevant variables, we attempt to recreate a multiple linear regression model. When predicting our model, we used natural spline and linear model for overall quality. However, the prediction error was less with the natural spline. To see if a multiple linear model does better, we fit the same variables on multiple regression. 
</font>

```{r}
#run a multiple linear regression of SalePrice on the same model
lm.fit.2 <- lm(SalePrice ~ Gr.Liv.Area + Overall.Qual + X1st.Flr.SF + MS.SubClass + X2nd.Flr.SF + Total.Bsmt.SF + MS.Zoning + Full.Bath + Kitchen.Qual + Neighborhood + Central.Air , data = housing.train)

summary(lm.fit.2)
```


```{r}
lm.preds.2 = predict(lm.fit.2, newdata=housing.test)
lm.MAE.2 <- mae(actual=housing.test$SalePrice, predicted=lm.preds.2, lm.fit.2)
lm.RMSE.2 <- rmse(actual=housing.test$SalePrice, predicted=lm.preds.2, lm.fit.2)

paste("MAE: ", lm.MAE.2 )
paste("RMSE: ", lm.RMSE.2)
paste("Mean RelErr: ", mean(calcRelErr(preds=lm.preds.2, housing.test$SalePrice)))
```

## Random Forests
<font color="#800000">
The random forest method can build prediction models using random forest regression trees, which are usually unpruned to give stronger predictions. We want to explore this as a possibility for a better 
</font>

```{r}
set.seed(1)
rf <- randomForest(SalePrice ~ .,data=housing.train, mtry=25, importance=TRUE)
rf

varImpPlot(rf,n.var = 20)

rf.preds <- predict(rf, newdata = housing.test)

rf.resid = housing.test$SalePrice - rf.preds

#Residual Plot for Random Forest Model 1
ggplot(data=data.frame(rf.preds, rf.resid), aes(rf.preds,rf.resid)) +
  geom_point(size=1,colour="lightblue") +
  geom_hline(yintercept = mean(rf.resid), color="red")+
  theme_bw() 

lm.MAE <- mae(actual=housing.test$SalePrice, predicted=rf.preds, rf)
lm.RMSE <- rmse(actual=housing.test$SalePrice, predicted=rf.preds, rf)

paste("MAE: ",lm.MAE)
paste("RMSE: ",lm.RMSE)
paste("Mean RelErr: ", mean(calcRelErr(preds=rf.preds, actual=housing.test$SalePrice)))


```

## Random Forest Variables
```{r}
rf.imp.plot <- varImpPlot(rf)
imp.vars <- as.character(rownames(rf.imp.plot)[order(rf.imp.plot, decreasing = TRUE)])
imp.vars <- imp.vars[c(80:158)]
```



```{r}
#Out-of-bag MSE curve
plot(rf)
```
<font color="#800000">
This plot shows that the Out-of-Bag (OOB) test error plateaus at around 400 trees. We will run a test to see which mtry value gives the lowest OOB test error.
</font>

```{r}
mtry <- tuneRF(housing.train[-80], housing.train$SalePrice, ntreeTry = 500,
               stepFactor = 1.5, improve = 0.01, trace = TRUE, plot = TRUE)
best.m <- mtry[mtry[,2] == min(mtry[,2]), 1]

print(mtry)
print(best.m)
```

<font color="#800000">
According to the tuning model, the random forest model that results in the lowest Out-of-Bag error estimates uses an mtry value of 39. The next three lowest OOB Errors come with mtry values of 18, 26, and 58. Note, we originally ran our model with an mtry value of 25 and that still gives us the lowest MAE. 
</font>

# Section 3: Key Findings/Take Aways

```{r}
residual.summary <- housing.test %>%
  mutate(residuals = abs(housing.test$SalePrice - rf.preds)) %>%
  group_by(Neighborhood) %>%
  dplyr:: summarise(mean.residual = mean(residuals)/1000)

ggplot(data = residual.summary, aes(x = reorder(Neighborhood, -mean.residual), 
                                    y = mean.residual)) + 
  geom_bar(stat="identity", fill = "Red", alpha = 0.4) +
  xlab("Neighborhood") +
  ylab("Avg. Residual Error ($1000's)") +
  ggtitle("Random Forest Avg. Residual Error Per Neighborhood") +
  theme(axis.text.x=element_text(angle = -90, vjust = 0))
```

<font color="#800000">
We see from the above data that StoneBr, NridgeHt and NoRidge are within the top 5 neighborhoods with the largest average residual error.  This would make sense given the high variability of home prices in these neighborhoods, as seen in the initial data review. We see similar behaviour for the neighborhoods Crawfor, and ClearCr.
</font>

# Home Improvement - Sale Price Calculator

```{r}
##Ingest information from User to set baseline understanding of home & understanding of type of renovations they desire to make
# Item asks directly correspond to variables considered to be meaningful in predicting home value

#check if as.doubles need to be as.factors?
#ensure that ranges asked of user are correct as per housing.processed (@Andy similar to exercise we did earlier today)
#Update nomenclature to either input "number" or "code"

info.ingest <- function() {

writeLines("Renovation Calculator!
We want to help you get the most bang for your buck.  Tell us a a bit about your property!\n")

writeLines("Approximately how much do you think your house is worth?")
house.price <- readline("Input: ")
house.price <- as.integer(house.price)

writeLines("
Blmngtn   --- Bloomington Heights
Blueste   --- Bluestem
BrDale    --- Briardale
BrkSide   --- Brookside
ClearCr   --- Clear Creek
CollgCr   --- College Creek
Crawfor   --- Crawford
Edwards   --- Edwards
Gilbert   --- Gilbert
IDOTRR    --- Iowa DOT and Rail Road
MeadowV   --- Meadow Village
Mitchel   --- Mitchell
NAmes     --- North Ames
NoRidge   --- Northridge
NPkVill   --- Northpark Villa
NridgHt   --- Northridge Heights
NWAmes    --- Northwest Ames
OldTown   --- Old Town
SWISU     --- South & West of Iowa State University
Sawyer    --- Sawyer
SawyerW   --- Sawyer West
Somerst   --- Somerset
StoneBr   --- Stone Brook
Timber    --- Timberland
Veenker   --- Veenker")

writeLines("\n")

writeLines("Tell us which neighborhood your home is in.")
writeLines("Enter the abbreviated neighborhood spelling corresponding to your neighborhood in the list above.") #For some reason this isn't reading in, but feel free to adjust
neighborhood <- readline("Input: ")

if(toupper(neighborhood) == "BLMNGTN") {
  neighborhood <- "Blmngtn"
} else if(toupper(neighborhood) == "BLUESTE") {
  neighborhood <- "Blueste"
} else if(toupper(neighborhood) == "BRDALE") {
  neighborhood <- "BrDale"
} else if(toupper(neighborhood) == "BRKSIDE") {
  neighborhood <- "BrkSide"
} else if(toupper(neighborhood) == "CLEARCR") {
  neighborhood <- "ClearCr"
} else if(toupper(neighborhood) == "COLLGCR") {
  neighborhood <- "CollgCr"
} else if(toupper(neighborhood) == "CRAWFOR") {
  neighborhood <- "Crawfor"
} else if(toupper(neighborhood) == "EDWARDS") {
  neighborhood <- "Edwards"
} else if(toupper(neighborhood) == "GILBERT") {
  neighborhood <- "Gilbert"
} else if(toupper(neighborhood) == "IDOTRR") {
  neighborhood <- "IDOTRR"
} else if(toupper(neighborhood) == "MEADOWV") {
  neighborhood <- "MeadowV"
} else if(toupper(neighborhood) == "MITCHEL") {
  neighborhood <- "Mitchel"
} else if(toupper(neighborhood) == "NAMES") {
  neighborhood <- "NAmes"
} else if(toupper(neighborhood) == "NORIDGE") {
  neighborhood <- "NoRidge"
} else if(toupper(neighborhood) == "NPKVILL") {
  neighborhood <- "NPkVill"
} else if(toupper(neighborhood) == "NRIDGHT") {
  neighborhood <- "NridgHt"
} else if(toupper(neighborhood) == "NWAMES") {
  neighborhood <- "NWAmes"
} else if(toupper(neighborhood) == "OLDTOWN") {
  neighborhood <- "OldTown"
} else if(toupper(neighborhood) == "SWISU") {
  neighborhood <- "SWISU"
} else if(toupper(neighborhood) == "SAWYER") {
  neighborhood <- "Sawyer"
} else if(toupper(neighborhood) == "SAWYERW") {
  neighborhood <- "SawyerW"
} else if(toupper(neighborhood) == "SOMERST") {
  neighborhood <- "Somerst"
} else if(toupper(neighborhood) == "STONEBR") {
  neighborhood <- "StoneBr"
} else if(toupper(neighborhood) == "TIMBER") {
  neighborhood <- "Timber"
} else if(toupper(neighborhood) == "VEENKER") {
  neighborhood <- "Veenker"
} else {
  neighborhood <- "NAmes"
}

writeLines("\n")

writeLines("20.	1-STORY 1946 & NEWER ALL STYLES
30.	1-STORY 1945 & OLDER
40.	1-STORY W/FINISHED ATTIC ALL AGES
45.	1-1/2 STORY - UNFINISHED ALL AGES
50.	1-1/2 STORY FINISHED ALL AGES 
60.	2-STORY 1946 & NEWER
70.	2-STORY 1945 & OLDER
75.	2-1/2 STORY ALL AGES
80.	SPLIT OR MULTI-LEVEL
85.	SPLIT FOYER
90.	DUPLEX - ALL STYLES AND AGES
120.	1-STORY PUD (Planned Unit Development) - 1946 & NEWER
150.	1-1/2 STORY PUD - ALL AGES
160.	2-STORY PUD - 1946 & NEWER
180.	PUD - MULTILEVEL - INCL SPLIT LEV/FOYER
190.	2 FAMILY CONVERSION - ALL STYLES AND AGES")

writeLines("\n")

writeLines("Describe your house design for us.")
writeLines("Enter the number that corresponds to your design from the list above.")
ms.num <- readline("Input: ")
ms.num <- as.integer(ms.num)
if(ms.num == 20) {
  ms.class <- "1-STORY 1946N"
} else if(ms.num == 30) {
  ms.class <- "1-STORY 1945O"
} else if(ms.num == 40) {
  ms.class <- "1-STORY UF.ATTIC.A"
} else if(ms.num == 45) {
  ms.class <- "1.5 STORY UF.A"
} else if(ms.num == 50) {
  ms.class <- "1.5-STORY F.ATTIC.A"
} else if(ms.num == 60) {
  ms.class <- "2-STORY 1946N"
} else if(ms.num == 70) {
  ms.class <- "2-STORY 1945O"
} else if(ms.num == 75) {
  ms.class <- "2.5-STORY A"
} else if(ms.num == 80) {
  ms.class <- "MULTILVL"
} else if(ms.num == 85) {
  ms.class <- "SPLIT FOYER"
} else if(ms.num == 90) {
  ms.class <- "DUPLEX.A"
} else if(ms.num == 120) {
  ms.class <- "1-STORY-PUD 1946N"
} else if(ms.num == 150) {
  ms.class <- "1.5-STORY-PUD.A"
} else if(ms.num == 160) {
  ms.class <- "2-STORY-PUD 1946N"
} else if(ms.num == 180) {
  ms.class <- "PUD-MULTILVL"
} else if(ms.num == 190) {
  ms.class <- "2 FAM CONV.A"
} else {
  ms.class <- "1-STORY 1946N"
} 

print(ms.class)
print(neighborhood)
print(house.price)


writeLines("\n")

baseline <- getbaselineRow(ms.class, neighborhood, house.price)

print(baseline$BsmtFin.SF.1)
writeLines("What year was your home built?")
year <- readline("Input: ")
year <- as.integer(year)

writeLines("\n")

writeLines("What is the total square footage of your lot?")
lot.area <- readline("Input: ")
lot.area <- as.numeric(lot.area)


writeLines("\n")


writeLines("A --- Agriculture
C --- Commercial
FV --- Floating Village Residential
I --- Industrial
RH --- Residential High Density
RL --- Residential Low Density
RM --- Residential Medium Density")

writeLines("\n")

writeLines("How is your house zoned?")
writeLines("Enter the abbreviation from the list above that corresponds to your house zone.")
zone <- readline("Input: ")
if(toupper(zone) == "A") {
  zone <- "A (agr)"
} else if(toupper(zone) == "C") {
  zone <- "C (all)"
} else if(toupper(zone) == "FV") {
  zone <- "FV"
} else if(toupper(zone) == "I") {
  zone <- "I (all)"
} else if(toupper(zone) == "RH") {
  zone <- "RH"
} else if(toupper(zone) == "RL") {
  zone <- "RL"
} else if(toupper(zone) == "RM") {
  zone <- "RM"
} else {
  zone <- "RL"
}

writeLines("\n")

writeLines("What is the square footage of your total home living area?")
liv.area <- readline("Input: ")
liv.area <- as.numeric(liv.area)

writeLines("\n")

writeLines("What is the apprx. square footage of the first level in your house?")
x1st.sf <- readline("Input: ")
x1st.sf <- as.numeric(x1st.sf)

writeLines("\n")

writeLines("Do you want to build an addition to the first level of your house?")
writeLines("Enter 'Y' for yes, or 'N' for no.")
addition <- readline("Input: ")

if(toupper(addition) == "N") {
  liv.area.upgrd <- 0
  x1st.sf.upgrd <- 0
} else {
  writeLines("Enter the approximate square-footage of the NEW addition's intended size.
If you do not want to upgrade, enter '0'.")
  x1st.sf.upgrd <- readline("Input: ")
  x1st.sf.upgrd <- as.numeric(x1st.sf.upgrd)
  liv.area.upgrd <- x1st.sf.upgrd
}

writeLines("\n")

if(ms.num %in% c(20,30,40,120)) {
  x2nd.sf <- 0
} else {
  writeLines("What is the apprx. square footage of the second level in your house?: ")
  x2nd.sf <- readline("Input: ")
  x2nd.sf <- as.numeric(x2nd.sf)
}



writeLines("\n")

writeLines("Enter the # size of your garage in car capacity, or enter '0' if you do not have a garage.
(ie. if you have a two car garage enter '2').")
garage <- readline("Input: ")
garage <- as.integer(garage)

writeLines("\n")

if(garage == 0) {
  garage.area <- 0
  garage.type <- "None"
} else {
  writeLines("What kind of garage do you have?")
  writeLines("2Types --- More than one type of garage
Attchd	--- Attached to home
Basment --- Basement Garage
BuiltIn --- Built-In (Garage part of house - typically has room above garage)
CarPort --- Car Port
Detchd --- Detached from home
None	--- No Garage")
  writeLines("Enter the abbreviated code closest to your garage type.")
  garage.type <- readline("Input: ")
  if(toupper(garage.type) == "2TYPES") {
    garage.type <- "2Types"
  } else if(toupper(garage.type) == "ATTCHD") {
    garage.type <- "Attchd"
  } else if(toupper(garage.type) == "BASMENT") {
    garage.type <- "Basment"
  } else if(toupper(garage.type) == "BUILTIN") {
    garage.type <- "BuiltIn"
  } else if(toupper(garage.type) == "CARPORT") {
    garage.type <- "CarPort"
  } else if(toupper(garage.type) == "DETCHD") {
    garage.type <- "Detchd"
  } else {
    garage.type <- "Attchd"
  }
  if(garage == 1) {
    garage.area <- 300
  } else if(garage == 2) {
    garage.area <- 518
  } else if(garage == 3) {
    garage.area <- 811
  } else if(garage == 4) {
    garage.area <- 960
  } else if(garage == 5) {
    garage.area <- 1184
  } else {
    garage.area <- 450
  }
}

writeLines("\n")

writeLines("What would you say is the overall quality of your home?")
writeLines("10.     Very Excellent \n 9.	Excellent \n 8.	Very Good \n 7.	Good \n 6.	Above Average \n 5.	Average \n 4.	Below Average \n 3.	Fair  \n 2.	Poor  \n 1.	Very Poor")
writeLines("Enter the number from the list above.")
overall.qual <- readline("Input: ")
overall.qual <- overall.qual

writeLines("\n")

if(overall.qual %in% c(1,2)) {
  exter.qual <- 1
} else if(overall.qual %in% c(3,4)) {
  exter.qual <- 2
} else if(overall.qual %in% c(5,6)) {
  exter.qual <- 3
} else if(overall.qual %in% c(7,8)) {
  exter.qual <- 4
} else if(overall.qual %in% c(9,10)) {
  exter.qual <- 5
} 

fire.qual <- 0
writeLines("Enter the number of fireplaces in your home (enter '0' if none).")
fire <- readline("Input: ")
fire <- as.integer(fire)

writeLines("\n")

if(!fire == 0) {
  writeLines("How would you rate the overall quality of your fireplace(s)?")
  writeLines("5. Excellent
4. Good
3. Typical/Average
2. Fair
1. Poor")
  writeLines("Enter the number that corresponds to your rating from the list above.")
  fire.qual <- readline("Input: ")
  fire.qual <- as.integer(fire.qual)
  if(!fire.qual %in% c(1:5)) {
    fire.qual <- 3
  }
}

writeLines("\n")

writeLines("What would you say is the overall quality of your kitchen?")
writeLines("5. Excellent
4. Good
3. Typical/Average
2. Fair
1. Poor")
writeLines("Enter the number that corresponds to your rating from the list above.")
ktchn.qual <- readline("Input: ")
ktchn.qual <- as.integer(ktchn.qual)

writeLines("\n")

writeLines("5. Excellent
4. Good
3. Typical/Average
2. Fair
1. Poor")
writeLines("Are you looking to improve the quality of your kitchen?
If yes, enter the target quality (#) from the list above that represents where you would like your kitchen to be. 
If no renovation is needed, enter `None`.")
ktchn.qual.upgrd <- readline("Input: ")
if(toupper(ktchn.qual.upgrd) == "NONE") {
  ktchn.qual.upgrd <- ktchn.qual
} else {
  ktchn.qual.upgrd <- as.integer(ktchn.qual.upgrd)
}

writeLines("\n")

writeLines("How would you rate your basement?")
writeLines("
6 --- Good living quarters
5 --- Average living quarters
4 --- Below average living quarters
3 --- Average Rec Room
2 --- Low Quality
1 --- Unfinished
None --- I don't have a basement")
writeLines("Enter the # rating for your basement, or 'None' if you do not have a basement.")
basement.fin <- readline("Input: ")

if(toupper(basement.fin) == "NONE") {
  basement <- "None"
  basement.fin <- 0
} else {
  basement.fin <- as.integer(basement.fin)
  if (basement.fin == 1) {
    basement <- "Unf"
  } else if(basement.fin == 2) {
    basement <- "LwQ"
  } else if(basement.fin == 3) {
    basement <- "Rec"
  } else if(basement.fin == 4) {
    basement <- "BLQ"
  } else if(basement.fin == 5) {
    basement <- "ALQ"
  } else {
    basement <- "GLQ"
  } 
}

writeLines("What is the ceiling height of your basement?")
writeLines("5. (100+ inches)	
4. (90-99 inches)
3. (80-89 inches)
2. (70-79 inches)
1. (<70 inches)
None	No Basement")
writeLines("Enter the number from the list above that corresponds to the approximate height.
Enter 'None' if you do not have a basement.")
bsmt.qual <- readline("Input: ")
if(toupper(bsmt.qual) == "NONE") {
  bsmt.qual <- 0
} else {
  bsmt.qual <- as.integer(bsmt.qual)
}

writeLines("\n")

writeLines("How many full bathrooms do you have on the first and/or second floors of your home?
(do not include HALF bathrooms)")
full.bath <- readline("Input: ")
full.bath <- as.integer(full.bath)

writeLines("\n")

writeLines("Are you looking to increase the number of full baths on these floors?
If yes, enter the number of bathrooms you wish to add. If no enter '0'.")
full.bath.upgrd <- readline("Input: ")
full.bath.upgrd <- as.integer(full.bath.upgrd)

writeLines("\n")

writeLines("How many half bathrooms do you have on the first and/or second floors of your home?
(ie. if you have two half bathrooms enter '2')")
half.bath <- readline("Input: ")
half.bath <- as.integer(full.bath)

writeLines("\n")

writeLines("Are you looking to increase the number of half bathrooms on these floors? 
If yes enter the number of bathrooms you wish to add.
If no enter '0'.")
half.bath.upgrd <- readline("Input: ")
half.bath.upgrd <- as.integer(half.bath.upgrd)

writeLines("\n")

writeLines("What type of utilities does your home have?")
writeLines("AllPub --- All public Utilities (E,G,W,& S)	
NoSewr --- Electricity, Gas, and Water (Septic Tank)
NoSeWa --- Electricity and Gas Only")
writeLines("Enter the code from the list above that corresponds to your utilities.")
utilities <- readline("Input: ")
if(toupper(utilities) == "NOSEWR") {
  utilities <- "NoSewr"
} else if(toupper(utilities) == "NOSEWA") {
  utilities <- "NoSeWa"
} else {
  utilities <- "AllPub"
}

writeLines("\n")

writeLines("Does your home have central air conditioning?")
writeLines("Enter 'Y' if yes, or 'N' if no.")
ac <- readline("Input: ")
ac <- toupper(ac)


baseline["Year.Built"] = as.double(year)
baseline["Gr.Liv.Area"] = liv.area
baseline["Overall.Qual"] = as.double(overall.qual)
baseline["Exter.Qual"] = exter.qual
baseline["X1st.Flr.SF"] = x1st.sf
baseline["X2nd.Flr.SF"] = x2nd.sf
baseline["Bsmt.Qual"] = as.double(bsmt.qual)
baseline["Fireplaces"] = as.double(fire)
baseline["Fireplace.Qu"] = fire.qual
baseline["Full.Bath"] = as.double(full.bath)
baseline["Half.Bath"] = as.double(half.bath)
baseline["Central.Air"] = ac
baseline["Kitchen.Qual"] = as.double(ktchn.qual)
baseline["Neighborhood"] = neighborhood
baseline["Garage.Cars"] = as.double(garage)
baseline["Garage.Type"] = garage.type
baseline["Garage.Area"] = garage.area
baseline["Utilities"] = utilities
baseline["Lot.Area"] = lot.area

renovated <- baseline

renovated["Gr.Liv.Area"] = liv.area + liv.area.upgrd
renovated["X1st.Flr.SF"] = x1st.sf + x1st.sf.upgrd
renovated["Kitchen.Qual"] = ktchn.qual.upgrd
renovated["Half.Bath"] = half.bath + half.bath.upgrd
renovated["Full.Bath"] = full.bath + full.bath.upgrd

na.fail(baseline)
print("baseline passed")
na.fail(renovated)

calcRenoValRF(baseline,renovated)
list(baseline = baseline, renovated = renovated)
}

```


```{r}
calcRenoValRF <- function(origHouse, remodeledHouse){
  
  origHomeVal <- predict(rf, origHouse)
  remHomeVal <- predict(rf, remodeledHouse)
  
  value.delta <- remHomeVal- origHomeVal
  percent.increase <- value.delta/origHomeVal
  percent.increase <- percent.increase * 100
  message <- paste("The changes you have proposed to make in your home upgrade have increased it's value by $", round(value.delta, digits = 2), "which is a", round(percent.increase, digits = 2),"% increase in value")
  print (message)
}

calcRenoValGAM <- function(origHouse, remodeledHouse){
  origHomeVal <- predict(gam.fit, origHouse)
  remHomeVal <- predict(gam.fit, remodeledHouse)
  
  value.delta <- remHomeVal- origHomeVal
  percent.increase <- value.delta/origHomeVal
  percent.increase <- percent.increase * 100
  message <- paste("The changes you have proposed to make in your home upgrade have increased it's value by $", round(value.delta, digits = 2), "which is a", round(percent.increase, digits = 2),"% increase in value")
  print (message)
}


```


# Resources

- https://www.federalreservehistory.org/essays/great-recession-of-200709
- https://rpubs.com/sknapp/667278
- https://medium.com/human-in-a-machine-world/mae-and-rmse-which-metric-is-better-e60ac3bde13d
- https://stackoverflow.com/questions/51449243/how-to-replace-empty-string-with-na-in-r-dataframe
- https://stackoverflow.com/questions/8161836/how-do-i-replace-na-values-with-zeros-in-an-r-dataframe
- https://stackoverflow.com/questions/24829674/r-random-forest-error-type-of-predictors-in-new-data-do-not-match
- https://www.listendata.com/2014/11/random-forest-with-r.html#Methods-to-find-Best-Split
- https://petolau.github.io/Analyzing-double-seasonal-time-series-with-GAM-in-R/
- https://www.usinflationcalculator.com/
- https://www.homeadvisor.com/cost/additions-and-remodels/build-an-addition/
- https://kitchenremodeling.roofingcontractorcompany.com/iowa/ames-ia/
- https://www.manta.com/cost-bathroom-remodeling-ames-ia
- https://patch.com/iowa/des-moines/iowa-homeowners-remodeling-costs-5-improvement-projects